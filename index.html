<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Liga de Baloncesto ‚Äî Rotaci√≥n Autom√°tica</title>
<style>
  :root{
    --bg:#0f1320; --card:#151a2b; --muted:#9aa4b2; --text:#e8edf5; --accent:#4da3ff; --ok:#2ecc71; --bad:#ff5c5c; --warn:#ffb347;
    --chip:#212845; --chip2:#1b2340;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:linear-gradient(180deg,#0b0f1c, #0f1320);}
  header{padding:18px 20px; border-bottom:1px solid #1e2540; position:sticky; top:0; background:rgba(15,19,32,.9); backdrop-filter:saturate(140%) blur(10px); z-index:2}
  header h1{margin:0; font-size:18px; color:var(--text); letter-spacing:.3px}
  header small{display:block; color:var(--muted)}
  main{padding:20px; display:grid; gap:16px; grid-template-columns: 1.2fr .8fr}
  @media (max-width:1080px){ main{grid-template-columns:1fr}}
  .card{background:var(--card); border:1px solid #1e2540; border-radius:12px; padding:16px; color:var(--text)}
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
  textarea, input, select, button{border-radius:10px; border:1px solid #2a335a; background:#0f152b; color:var(--text)}
  textarea{width:100%; min-height:130px; padding:10px 12px; resize:vertical}
  input, select{padding:10px 12px}
  button{padding:10px 14px; cursor:pointer; font-weight:600}
  button.primary{background:var(--accent); border-color:#357ee6; color:#041028}
  button.ghost{background:transparent}
  button.warn{background:var(--warn); border-color:#e79a2f; color:#2b1c00}
  button.ok{background:var(--ok); border-color:#1fa85a; color:#062013}
  button.bad{background:var(--bad); border-color:#d54f4f; color:#2b0000}
  .col2{display:grid; grid-template-columns:1fr 1fr; gap:12px}
  .chip{display:inline-flex; align-items:center; gap:8px; background:var(--chip); border:1px solid #2a335a; padding:6px 10px; border-radius:999px; font-size:13px}
  .chip small{color:var(--muted)}
  .list{display:flex; flex-wrap:wrap; gap:8px}
  .title{font-weight:700; margin:0 0 6px 0}
  .muted{color:var(--muted); font-size:13px}
  hr{border:none; border-top:1px solid #20284b; margin:12px 0}
  .teams{display:grid; grid-template-columns:1fr 1fr; gap:12px}
  .team{background:var(--chip2); border:1px solid #2a335a; border-radius:12px; padding:12px}
  .team h3{margin:0 0 8px 0; font-size:15px}
  .queue{min-height:48px}
  .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; background:#0a1026; border:1px solid #2a335a; border-radius:999px; font-size:13px}
  .section-label{font-size:12px; letter-spacing:.2px; color:var(--muted); margin-bottom:6px; text-transform:uppercase}
  .state{display:flex; gap:10px; flex-wrap:wrap}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0b1024; border:1px solid #2a335a; padding:2px 6px; border-radius:6px; font-size:12px; color:#cfe0ff}
  .small{font-size:12px}
  .danger{color:#ff9c9c}
  .success{color:#9dffbf}
</style>
</head>
<body>
<header>
  <h1>üèÄ Rotaci√≥n Autom√°tica ‚Äî Liga de Enmanuel</h1>
  <small>Reglas: P1 solo liga ¬∑ P2+ retador = 3 liga + 2 invitados ¬∑ Campe√≥n intacto ¬∑ 2 seguidas ‚áí standby ¬∑ 10 nuevos distintos ¬∑ Perdedores al final ¬∑ Ciclo infinito ¬∑ If happens (falta de invitados) = completar con liga</small>
</header>

<main>
  <!-- IZQUIERDA: Control principal -->
  <section class="card">
    <h2 class="title">1) Cargar lista inicial</h2>
    <p class="muted">Pega tu lista (una por l√≠nea). Marca invitados escribiendo <span class="kbd">(invitado)</span> en la l√≠nea. El orden se respeta.</p>
    <textarea id="seed" placeholder="1. Max Diclo
2. Eliam Diclo
3. Juan (invitado)
4. Jorge (invitado)
..."></textarea>
    <div class="row">
      <button class="primary" id="parseBtn">Cargar listas</button>
      <button class="ghost" id="clearBtn">Reiniciar todo</button>
    </div>
    <hr>
    <div class="col2">
      <div>
        <div class="section-label">Liga (cola)</div>
        <div id="leagueList" class="list queue"></div>
      </div>
      <div>
        <div class="section-label">Invitados (cola)</div>
        <div id="guestList" class="list queue"></div>
      </div>
    </div>
  </section>

  <!-- DERECHA: Estado -->
  <section class="card">
    <h2 class="title">Estado</h2>
    <div class="state">
      <span class="chip">Partido actual: <b id="matchNo">‚Äî</b></span>
      <span class="chip">Campe√≥n racha: <b id="streak">0</b></span>
      <span class="chip">Modo: <b id="modeLabel">‚Äî</b></span>
    </div>
    <div class="row" style="margin-top:8px">
      <span class="chip"><small>Campe√≥n:</small> <b id="champNames">‚Äî</b></span>
      <span class="chip"><small>Standby:</small> <b id="standbyNames">‚Äî</b></span>
    </div>
  </section>

  <!-- Equipos del partido -->
  <section class="card" style="grid-column:1/-1">
    <h2 class="title">2) Partido en curso</h2>
    <div class="teams">
      <div class="team">
        <h3 id="labelA">Equipo A</h3>
        <div id="teamA" class="list"></div>
      </div>
      <div class="team">
        <h3 id="labelB">Equipo B</h3>
        <div id="teamB" class="list"></div>
      </div>
    </div>
    <div class="row" style="margin-top:12px">
      <button class="ok" id="winA">Gana Equipo A</button>
      <button class="bad" id="winB">Gana Equipo B</button>
      <button class="ghost" id="nextBtn">‚ûú Armar pr√≥ximo partido</button>
    </div>
    <p class="muted small">P1: usa 10 primeros de la liga (equipos aleatorios). P2+: el campe√≥n se mantiene y el retador es 3 de liga + 2 invitados (si faltan invitados, completar con liga). Al lograr 2 seguidas, el campe√≥n va a standby y se arma un partido de 10 nuevos distintos a los que estaban en cancha; luego el standby regresa vs el nuevo ganador.</p>
  </section>

  <!-- Utilidades de administraci√≥n -->
  <section class="card">
    <h2 class="title">3) Utilidades</h2>
    <div class="col2">
      <div>
        <div class="section-label">Llegada tarde (se agrega al final)</div>
        <div class="row">
          <input id="lateName" placeholder="Nombre exacto" />
          <select id="lateRole">
            <option value="league">Liga</option>
            <option value="guest">Invitado</option>
          </select>
          <button id="lateAdd">Agregar</button>
        </div>
      </div>
      <div>
        <div class="section-label">Se fue del campe√≥n (aplica reemplazo)</div>
        <div class="row">
          <select id="leftCount">
            <option value="1">1 jugador</option>
            <option value="2">2 jugadores</option>
            <option value="3">3 jugadores</option>
            <option value="4">4 jugadores</option>
            <option value="5">Equipo completo (5)</option>
          </select>
          <button id="applyLeft" class="warn">Aplicar reemplazos</button>
        </div>
        <p class="muted small">Regla: sale(n) 1‚Äì3 ‚áí suben mismos de liga; 4 ‚áí suben 3 liga + 1 invitado; 5 ‚áí suben 3 liga + 2 invitados.</p>
      </div>
    </div>
  </section>
</main>

<script>
/* ======= Estado ======= */
const SKEY = 'liga-rotacion-v2';

let state = {
  leagueQueue: [],   // cola de liga (en orden circular)
  guestQueue: [],    // cola de invitados
  champion: [],      // equipo campe√≥n actual (5) o []
  championStreak: 0, // racha actual del campe√≥n
  standby: [],       // equipo en standby (si se activ√≥ 2 seguidas)
  matchNo: 0,
  currentA: [],      // equipo A del partido en curso
  currentB: [],      // equipo B del partido en curso
  mode: 'idle',      // 'idle' | 'normal' | 'standbyMatch'
  lastOnCourt: new Set(), // jugadores que estuvieron en la √∫ltima cancha (para excluir en partido de 10 nuevos)
};

/* ======= Utilidades ======= */
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));

function save(){ localStorage.setItem(SKEY, JSON.stringify(state)); }
function load(){
  const raw = localStorage.getItem(SKEY);
  if(!raw) return;
  try{ state = JSON.parse(raw); state.lastOnCourt = new Set(state.lastOnCourt || []);}catch(e){}
}

function resetAll(){
  state = {
    leagueQueue: [], guestQueue: [],
    champion: [], championStreak: 0, standby: [],
    matchNo: 0, currentA: [], currentB: [], mode:'idle', lastOnCourt:new Set()
  };
  save(); render();
}

function pill(name){ const span=document.createElement('span'); span.className='pill'; span.textContent=name; return span; }

function renderQueues(){
  const l=$('#leagueList'); l.innerHTML=''; state.leagueQueue.forEach(n=>l.appendChild(pill(n)));
  const g=$('#guestList'); g.innerHTML=''; state.guestQueue.forEach(n=>g.appendChild(pill(n)));
}

function renderTeams(){
  const a=$('#teamA'); a.innerHTML=''; state.currentA.forEach(n=>a.appendChild(pill(n)));
  const b=$('#teamB'); b.innerHTML=''; state.currentB.forEach(n=>b.appendChild(pill(n)));
  $('#labelA').textContent = state.mode==='standbyMatch' ? 'Equipo A (10 nuevos)' : 'Equipo A';
  $('#labelB').textContent = state.mode==='standbyMatch' ? 'Equipo B (10 nuevos)' : 'Equipo B';
}

function renderState(){
  $('#matchNo').textContent = state.matchNo || '‚Äî';
  $('#streak').textContent = state.championStreak;
  $('#modeLabel').textContent = state.mode==='idle' ? 'listo' : state.mode==='normal' ? 'normal' : 'standby';
  $('#champNames').textContent = state.champion.length? state.champion.join(', ') : '‚Äî';
  $('#standbyNames').textContent = state.standby.length? state.standby.join(', ') : '‚Äî';
}

function render(){ renderQueues(); renderTeams(); renderState(); }

/* ======= Parsing ======= */
function parseSeed(text){
  const lines = text.split('\n').map(s=>s.replace(/^\s*\d+[\.\)]\s*/,'').trim()).filter(Boolean);
  const league=[], guest=[];
  for(const line of lines){
    if(/\(invitado\)/i.test(line)){
      guest.push(line.replace(/\s*\(invitado\)\s*/i,'').trim());
    }else{
      league.push(line);
    }
  }
  return {league, guest};
}

/* ======= Core Reglas ======= */

// extrae del frente, ciclando al final
function popFront(queue){ return queue.shift(); }
function pushBack(queue, v){ queue.push(v); }

function takeNFromQueue(queue, n, excludeSet = null){
  const out=[];
  let safety=0;
  while(out.length<n && queue.length && safety < queue.length*3){
    const v = popFront(queue);
    const excluded = excludeSet && excludeSet.has(v);
    if(!excluded){
      out.push(v);
    }
    pushBack(queue, v);
    safety++;
    // evitar bucle infinito cuando no hay elegibles
    if(safety>=queue.length*3 && out.length<n){
      // forzamos tomar aunque est√© excluido (no ideal, pero evita trabarse si faltan jugadores)
      const v2 = popFront(queue);
      out.push(v2);
      pushBack(queue, v2);
    }
  }
  return out;
}

function removeFromArray(arr, name){
  const idx = arr.indexOf(name);
  if(idx>=0) arr.splice(idx,1);
}

function sendLosersToQueues(team){
  // Perdedores vuelven al final de su cola, manteniendo categor√≠as
  for(const name of team){
    // si est√° (o pertenece) a invitados?
    // La categor√≠a original se infiere: si existe en guestQueue actual o alguna de las colas + equipos.
    // Dado que todos los invitados provienen de guestQueue, asumimos que si est√°n en guestQueue o en currentB como invitados,
    // aqu√≠ determinamos: si no existe en leagueQueue y s√≠ existe (o existi√≥) en invitados globales.
    // Simplificamos: si el nombre no existe en leagueQueue pero existe en guestQueue OR estaba en currentA/B marcado como invitado.
    // Para robustez, mantenemos un set de "todosLosInvitados". Lo construiremos al parsear.
  }
}

let allGuests = new Set(); // poblado en parse

function isGuestName(name){
  return allGuests.has(name);
}

// manda perdedores al final de su respectiva cola
function enqueueLosers(team){
  for(const name of team){
    if(isGuestName(name)){
      pushBack(state.guestQueue, name);
    }else{
      pushBack(state.leagueQueue, name);
    }
  }
}

// arma P1: 10 primeros de liga, equipos aleatorios de 5 y 5
function buildMatchP1(){
  if(state.leagueQueue.length < 10){
    alert('Se necesitan al menos 10 jugadores de liga para el Partido 1.');
    return false;
  }
  const first10 = [];
  for(let i=0;i<10;i++) first10.push(popFront(state.leagueQueue));
  // devolverlos al final en el mismo orden de extracci√≥n (se reinsertar√°n tras resultado)
  // pero durante el partido no est√°n en cola. Al finalizar, perdedores ir√°n al final.
  // Para formar equipos aleatorios de 5:
  const shuffled = first10.slice().sort(()=>Math.random()-0.5);
  state.currentA = shuffled.slice(0,5);
  state.currentB = shuffled.slice(5,10);
  state.mode = 'normal';
  state.champion = []; state.championStreak = 0; state.standby=[];
  state.matchNo = 1;
  state.lastOnCourt = new Set([...state.currentA, ...state.currentB]);
  return true;
}

// arma retador (P2+): campe√≥n se mantiene como A; retador = 3 liga + 2 invitados (if happens: completar con liga)
function buildChallenger(){
  // 3 de liga
  const L = takeNFromQueue(state.leagueQueue, 3);
  // 2 invitados (o completar con liga)
  let G = takeNFromQueue(state.guestQueue, 2);
  if(G.length<2){
    const faltan = 2 - G.length;
    const extra = takeNFromQueue(state.leagueQueue, faltan);
    G = G.concat(extra);
  }
  return L.concat(G);
}

// arma partido normal (campe√≥n vs retador)
function buildMatchNormal(){
  if(state.champion.length !== 5){
    alert('No hay campe√≥n vigente. Inicia con Partido 1.');
    return false;
  }
  state.currentA = state.champion.slice();
  state.currentB = buildChallenger();
  state.mode = 'normal';
  state.matchNo = (state.matchNo||0)+1;
  state.lastOnCourt = new Set([...state.currentA, ...state.currentB]);
  return true;
}

// arma partido de 10 nuevos distintos (tras standby): dos equipos, cada uno 3 liga + 2 invitados
function buildMatchStandby(){
  const exclude = new Set(state.lastOnCourt);
  // Equipo A
  let aL = takeNFromQueue(state.leagueQueue, 3, exclude);
  let aG = takeNFromQueue(state.guestQueue, 2, exclude);
  if(aG.length<2){
    const faltan = 2 - aG.length;
    aL = aL.concat(takeNFromQueue(state.leagueQueue, faltan, exclude));
  }
  const A = aL.concat(aG);

  // Equipo B
  let bL = takeNFromQueue(state.leagueQueue, 3, exclude);
  let bG = takeNFromQueue(state.guestQueue, 2, exclude);
  if(bG.length<2){
    const faltan = 2 - bG.length;
    bL = bL.concat(takeNFromQueue(state.leagueQueue, faltan, exclude));
  }
  const B = bL.concat(bG);

  state.currentA = A;
  state.currentB = B;
  state.mode = 'standbyMatch';
  state.matchNo = (state.matchNo||0)+1;
  state.lastOnCourt = new Set([...A, ...B]);
  return true;
}

// registrar ganador (A/B)
function registerWin(winner){
  if(state.mode==='idle'){ alert('Arma un partido primero.'); return; }

  const A = state.currentA.slice();
  const B = state.currentB.slice();

  if(state.mode==='normal'){
    // Caso normal: campe√≥n vs retador
    // Si no hay campe√≥n (solo puede pasar en P1)
    if(state.champion.length===0){
      // El ganador se vuelve campe√≥n
      const winnerTeam = (winner==='A')? A : B;
      const loserTeam = (winner==='A')? B : A;
      state.champion = winnerTeam.slice();
      state.championStreak = 1;
      // perdedores: van al final (son de liga en P1)
      enqueueLosers(loserTeam);
    }else{
      // S√≠ hay campe√≥n
      const champWon = (winner==='A'); // A es el campe√≥n
      if(champWon){
        state.championStreak += 1;
        // perdedor (retador) a su cola
        enqueueLosers(B);
        if(state.championStreak>=2){
          // Activa standby
          state.standby = state.champion.slice();
          state.champion = []; // no hay campe√≥n durante el partido de 10 nuevos
          state.championStreak = 0;
        }
      }else{
        // gan√≥ el retador: se vuelve campe√≥n con racha 1
        // antiguo campe√≥n (A) pasa al final de su cola
        enqueueLosers(A);
        state.champion = B.slice();
        state.championStreak = 1;
      }
    }
  }else if(state.mode==='standbyMatch'){
    // Partido especial de 10 nuevos. El ganador se convierte en "nuevo campe√≥n".
    const winnerTeam = (winner==='A')? A : B;
    const loserTeam = (winner==='A')? B : A;

    // perdedor va a cola correspondiente
    enqueueLosers(loserTeam);

    // El standby regresa para enfrentar al nuevo campe√≥n en el PR√ìXIMO partido.
    // Pero de acuerdo a tus reglas y a nuestro flujo: aqu√≠ establecemos al ganador como campe√≥n actual (racha 1)
    // y el standby estar√° guardado para el siguiente partido (se usar√° buildMatchAfterStandby()).
    state.champion = winnerTeam.slice();
    state.championStreak = 1;
  }

  // limpiar cancha actual
  state.currentA = []; state.currentB = [];
  save(); render();
}

function buildNext(){
  // Si no hay partido a√∫n, construir P1
  if(state.matchNo===0){
    const ok = buildMatchP1();
    if(ok){ save(); render(); }
    return;
  }

  // Si se activ√≥ standby (standby lleno y champion vac√≠o) => armar partido de 10 nuevos
  if(state.standby.length===5 && state.champion.length===0){
    const ok = buildMatchStandby();
    if(ok){ save(); render(); }
    return;
  }

  // Si venimos de un partido de 10 nuevos y hay standby almacenado,
  // el siguiente partido debe ser CAMPE√ìN ACTUAL vs STANDBY que regresa.
  // Nuestro m√©todo: si existe standby y tambi√©n hay champion (por el partido anterior),
  // el pr√≥ximo partido ser√° "normal" pero con A=champion y B=formado como retador.
  // PERO regla tuya: el standby regresa "a jugar contra el nuevo ganador".
  // Eso significa que el siguiente match debe ser exactly: champion vs standby (no retador de 3+2).
  if(state.standby.length===5 && state.champion.length===5 && state.mode!=='standbyMatch' && state.currentA.length===0 && state.currentB.length===0){
    // Creamos partido especial: campe√≥n vs standby directo
    state.currentA = state.champion.slice();
    state.currentB = state.standby.slice();
    state.mode = 'normal'; // se comporta como normal respecto a rachas/colas
    state.matchNo = (state.matchNo||0)+1;
    state.lastOnCourt = new Set([...state.currentA, ...state.currentB]);
    // una vez armado el enfrentamiento, vaciamos standby (ya volvi√≥)
    state.standby = [];
    save(); render();
    return;
  }

  // Caso normal: construir siguiente partido (campe√≥n vs retador 3+2)
  if(state.champion.length===5){
    const ok = buildMatchNormal();
    if(ok){ save(); render(); }
    return;
  }

  // Fallback
  alert('No hay suficiente informaci√≥n para armar el siguiente partido. Revisa el estado.');
}

/* ======= Llegadas tarde ======= */
function addLate(){
  const name = $('#lateName').value.trim();
  const role = $('#lateRole').value;
  if(!name){ alert('Escribe un nombre.'); return; }
  if(role==='league') pushBack(state.leagueQueue, name);
  else pushBack(state.guestQueue, name);
  // si llega tarde y era invitado, m√°rcalo como tal para las colas futuras
  if(role==='guest') allGuests.add(name);
  $('#lateName').value='';
  save(); render();
}

/* ======= Reemplazos por salidas del campe√≥n ======= */
function applyLeft(){
  const cnt = parseInt($('#leftCount').value,10);
  if(state.champion.length!==5){ alert('No hay campe√≥n vigente.'); return; }
  if(cnt<1 || cnt>5){ return; }

  // quitar cnt jugadores del campe√≥n (tomamos desde el final para simplicidad)
  const removed = state.champion.splice(0, cnt); // salen los primeros cnt (orden no especificado)
  // Los que se van NO vuelven a cola (se fueron).

  if(cnt<=3){
    // suben cnt de liga
    const add = takeNFromQueue(state.leagueQueue, cnt);
    state.champion = state.champion.concat(add);
  }else if(cnt===4){
    const addL = takeNFromQueue(state.leagueQueue, 3);
    let addG = takeNFromQueue(state.guestQueue, 1);
    if(addG.length<1){ addG = takeNFromQueue(state.leagueQueue, 1); } // if happens
    state.champion = state.champion.concat(addL, addG);
  }else if(cnt===5){
    const addL = takeNFromQueue(state.leagueQueue, 3);
    let addG = takeNFromQueue(state.guestQueue, 2);
    if(addG.length<2){
      const faltan = 2 - addG.length;
      addG = addG.concat(takeNFromQueue(state.leagueQueue, faltan));
    }
    state.champion = addL.concat(addG); // equipo completo reemplazado
  }
  save(); render();
}

/* ======= Eventos UI ======= */
$('#parseBtn').addEventListener('click', ()=>{
  const {league, guest} = parseSeed($('#seed').value);
  if(league.length<10){ alert('Necesitas al menos 10 jugadores de LIGA.'); return; }
  state.leagueQueue = league.slice();
  state.guestQueue = guest.slice();
  allGuests = new Set(guest);
  state.champion=[]; state.championStreak=0; state.standby=[]; state.matchNo=0; state.currentA=[]; state.currentB=[]; state.mode='idle'; state.lastOnCourt=new Set();
  save(); render();
});

$('#clearBtn').addEventListener('click', resetAll);
$('#nextBtn').addEventListener('click', buildNext);
$('#winA').addEventListener('click', ()=>{ registerWin('A'); render(); });
$('#winB').addEventListener('click', ()=>{ registerWin('B'); render(); });
$('#lateAdd').addEventListener('click', addLate);
$('#applyLeft').addEventListener('click', applyLeft);

/* ======= Init ======= */
load(); render();
</script>
</body>
</html>
